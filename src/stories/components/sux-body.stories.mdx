import { extractArgTypes } from '@pxtrn/storybook-addon-docs-stencil';
import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs/blocks';
import { html, render } from 'lit-html';

<Meta title="Components/Typography/Body" component="sux-body" argTypes={extractArgTypes('sux-body')} />

# Typography / Body

Body is a typography component used to create various levels of hierarchies between text.

export const BodyDefault = args => {
  return html`
    <div style="padding: 10%; justify-content: center; gap:16px;">
      <sux-body .size="${args.size}" .variant="${args.variant}">
        From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to
        fit into their framework.
      </sux-body>
    </div>
  `;
};

<Canvas>
  <Story name="BodyDefault">{BodyDefault.bind()}</Story>
</Canvas>

## Table of options / API

From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to fit into their framework.

<ArgsTable of="sux-body" />

### Classification

Headings can be displayed in serif or sans serif (default).

export const BodyClassification = args => {
  return html`
    <div style="padding: 10%; justify-content: center; gap:16px;">
      <!-- Extra Small -->
      <sux-body size="xs" variant="mono">Extra Small</sux-body>
      <sux-body size="xs" .variant="${args.variant}">
        From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to
        fit into their framework.
      </sux-body>
      <br />
      <!-- Extra Small -->
      <sux-body size="xs" variant="mono"> Small</sux-body>
      <sux-body size="s" .variant="${args.variant}">
        From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to
        fit into their framework.
      </sux-body>
      <br />
      <!-- Medium -->
      <sux-body size="xs" variant="mono">Medium</sux-body>
      <sux-body size="m" .variant="${args.variant}">
        From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to
        fit into their framework.
      </sux-body>
      <br />
      <!-- Large -->
      <sux-body size="xs" variant="mono">Large</sux-body>
      <sux-body size="l" .variant="${args.variant}">
        From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to
        fit into their framework.
      </sux-body>
      <br />
      <!-- X Large -->
      <sux-body size="xs" variant="mono">Extra Large</sux-body>
      <sux-body size="xl" .variant="${args.variant}">
        From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to
        fit into their framework.
      </sux-body>
      <br />
      <!-- XX Large -->
      <sux-body size="xs" variant="mono">XX Large</sux-body>
      <sux-body size="xxl" .variant="${args.variant}">
        From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to
        fit into their framework.
      </sux-body>
      <br />
      <!-- Extra Extra Extra Large -->
      <sux-body size="xs" variant="mono">XXX Large</sux-body>
      <sux-body size="xxxl" .variant="${args.variant}">
        From the design point of view, each component has a number of options. These options and their names are platform agnostic, and each implementation should adapt these to
        fit into their framework.
      </sux-body>
    </div>
  `;
};

<Canvas>
  <Story name="BodyClassification">{BodyClassification.bind()}</Story>
</Canvas>

### Weight

Heading weight is another way to create or enhance visual hierarchy, in addition to size. Heavier and lighter weights can add personality or style to an experience.

export const HeadingWeight = args => {
  return html`
    <div style="padding: 10%; justify-content: center; gap:16px;">
      <sux-heading size="s" variant="sans-serif" weight="light"> A Light Sans Serif Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="sans-serif" weight="regular"> A Regular Sans Serif Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="sans-serif" weight="semibold"> A Semi Bold Sans Serif Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="sans-serif" weight="bold"> A Bold Sans Serif Heading looks like this. </sux-heading>
      <br />
      <sux-heading size="s" variant="serif" weight="light"> A Light Serif Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="serif" weight="regular"> A Regular Serif Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="serif" weight="semibold"> A Semi Bold Serif Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="serif" weight="bold"> A Bold Serif Heading looks like this. </sux-heading>
      <br />
      <sux-heading size="s" variant="mono" weight="light"> A Light Monospace Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="mono" weight="regular"> A Regular Monospace Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="mono" weight="semibold"> A Semi Bold Monospace Heading looks like this. </sux-heading>
      <sux-heading size="s" variant="mono" weight="bold"> A Bold Monospace Heading looks like this. </sux-heading>
    </div>
  `;
};

<Canvas>
  <Story name="HeadingWeight">{HeadingWeight.bind()}</Story>
</Canvas>

### Size

Headings have a variety of sizes available. These sizes are defined using T-shirt sizing in order to support multiple scales without direct correlation to pixel values.

export const HeadingSize = args => {
  return html`
    <div style="padding: 10%; justify-content: center; gap:16px;">
      <sux-heading size="xs" variant="sans-serif" weight="regular"> Extra Small heading </sux-heading>
      <sux-heading size="s" variant="sans-serif" weight="regular"> Small heading </sux-heading>
      <sux-heading size="m" variant="sans-serif" weight="regular"> Medium heading </sux-heading>
      <sux-heading size="l" variant="sans-serif" weight="regular"> Large heading </sux-heading>
      <sux-heading size="xl" variant="sans-serif" weight="regular"> X Large heading </sux-heading>
      <sux-heading size="xxl" variant="sans-serif" weight="regular"> XX Large heading </sux-heading>
      <br />
    </div>
  `;
};

<Canvas>
  <Story name="HeadingSize">{HeadingSize.bind()}</Story>
</Canvas>
